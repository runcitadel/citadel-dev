#!/usr/bin/env bash
set -euo pipefail

source $(dirname $0)/../functions.sh
source $(dirname $0)/../spinner.sh
source $(dirname $0)/../utils.sh

CLI_NAME="$(basename $0)"
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
IMAGE_NAME=citadel
CONTAINER_NAME=citadel

if [ -z ${1+x} ]; then
  command=""
else
  command="$1"
fi

# Install dependencies
if [[ "$command" = "install" ]]; then
  # install Docker
  echo 'Installing Docker...'
  if command -v "docker" >/dev/null 2>&1; then
    echo 'Docker is already installed. Skipping...'
  else
    sudo $SCRIPT_DIR/../scripts/install-docker.sh
  fi

  # install Sysbox
  echo 'Installing Sysbox...'
  if command -v "sysbox" >/dev/null 2>&1; then
    echo 'Sysbox is already installed. Skipping...'
  else
    sudo $SCRIPT_DIR/../scripts/install-sysbox.sh
  fi

  # build Citadel Docker image
  echo 'Building Docker image...'
  docker build -t $IMAGE_NAME $SCRIPT_DIR/..

  echo 'Citadel dependencies installed successfully.'
  exit
fi

# Boot the container
if [[ "$command" = "boot" ]]; then
  check_dependencies

  shift

  # default values
  network="regtest"
  hostname="citadel-dev"

  # parse arguments
  for arg in "$@"; do
    case "$arg" in
    -n | --network)
      case $2 in
      "mainnet" | "testnet" | "signet" | "regtest")
        network=$2
        shift 1
        ;;
      *)
        echo "Not a valid value for network"
        exit 1
        ;;
      esac
      ;;
    *)
      shift 1
      ;;
    esac
  done

  echo "Booting..."

  docker run --runtime sysbox-runc --env NETWORK=$network -d -P --name $CONTAINER_NAME --hostname $hostname $IMAGE_NAME &>/dev/null || {
    read -p "The container exists already. Do you want to start it? (y/N) " should_start
    echo
    if [[ $should_start =~ [Yy]$ ]]; then
      $CLI_NAME start
    else
      exit 1
    fi
  }

  start_spinner "Citadel is spinning up containers... This will only take a minute."
  wait_for_dashboard
  stop_spinner $?

  show_welcome $network $hostname $(get_container_ip)
  read -p "Do you want to log in now? (y/N) " should_login
  echo
  if [[ $should_login =~ [Yy]$ ]]; then
    $CLI_NAME ssh
  fi

  exit
fi

# Show the container IP
if [[ "$command" = "info" ]]; then
  check_dependencies
  check_container

  show_welcome $(get_node_network) $(get_container_hostname) $(get_container_ip)

  printf "\nLogin with \"${CLI_NAME} ssh\" or run a command directly with \"${CLI_NAME} run\"\n\n"
  exit
fi

# Get an SSH session inside the container
if [[ "$command" = "ssh" ]]; then
  check_dependencies
  check_container

  # get host IPs
  addresses=($(ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'))

  # get container port
  port=$(docker container inspect --format='{{(index (index .NetworkSettings.Ports "22/tcp") 0).HostPort}}' $CONTAINER_NAME)

  if [ -z ${2+x} ]; then
    ssh citadel@${addresses[0]} -p $port
  else
    shift

    # parse arguments
    for arg in "$@"; do
      case "$arg" in
      list)
        printf "Use one of the following commands to ssh in from another device:\n\n"
        for address in ${addresses[@]}; do
          echo "ssh citadel@${address} -p $port"
        done
        exit 1
        ;;
      help | *)
        cat <<EOF
Usage: ${CLI_NAME} ssh <command>

Commands:
    help              Show this help message
    list              List IP adresses
EOF
        exit 1
        ;;
      esac
    done
  fi

  exit
fi

# Start the container
if [[ "$command" = "start" ]]; then
  check_dependencies
  check_container

  if [ "$(docker container inspect -f '{{.State.Running}}' $CONTAINER_NAME)" == "true" ]; then
    echo "Citadel is already running"
    exit 1
  else
    printf "Starting Citadel...\n\n"
    docker start $CONTAINER_NAME &>/dev/null
  fi
  exit
fi

# Stop the container
if [[ "$command" = "stop" ]]; then
  check_dependencies
  check_container

  echo "Shutting down Citadel..."
  docker stop $CONTAINER_NAME &>/dev/null
  exit
fi

# Reload the Citadel service
if [[ "$command" = "reload" ]]; then
  check_dependencies
  check_container

  printf "Reloading the Citadel service...\n\n"
  run_in_container "scripts/stop && scripts/configure && scripts/start"
  exit
fi

# Destroy the container
if [[ "$command" = "destroy" ]]; then
  check_dependencies
  check_container

  echo "WARNING: This will completely remove the container and its data."
  echo "If you just want to stop the container run \"$CLI_NAME stop\""
  read -p "Are you sure? (y/N) "
  echo
  if [[ $REPLY =~ [Yy]$ ]]; then
    echo "Destroying container..."
    docker rm -f $CONTAINER_NAME &>/dev/null
    echo "Citadel container destroyed"
  else
    echo "Cancelled."
  fi
  exit
fi

# List container services
if [[ "$command" = "containers" ]]; then
  check_dependencies
  check_container

  run_in_container "docker compose config --services"
  exit
fi

# Rebuild a container service
if [[ "$command" = "rebuild" ]]; then
  check_dependencies
  check_container

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  fi

  container="$2"
  run_in_container "                    \
       docker compose build $container  \
    && docker compose stop $container   \
    && docker compose rm -f $container  \
    && DEVICE_HOSTS=$(get_container_hostname) docker compose up -d $container"
  exit
fi

# Backup the container
if [[ "$command" = "backup" ]]; then
  check_dependencies
  check_container

  current_date=$(date '+%Y-%m-%d')

  echo "Stopping Citadel services..."
  run_in_container "scripts/stop" &>/dev/null
  echo "Creating snapshot..."
  docker commit $CONTAINER_NAME citadel-backup:${current_date}
  echo "Backing up..."
  docker save citadel-backup:${current_date} | gzip >citadel-backup-${current_date}.tar.gz
  echo "Cleaning up..."
  docker rmi citadel-backup:${current_date} &>/dev/null
  echo "Done! Backup saved to ./citadel-backup-${current_date}.tar.gz"
  exit
fi

# Restore a backup
if [[ "$command" = "restore" ]]; then
  check_dependencies

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  fi

  # TODO: we aren't really using the date here atm
  backup_date=${2:15:10}

  # check for current container
  docker container inspect $CONTAINER_NAME &>/dev/null || {
    # load & rename
    echo "Restoring from backup $2..."
    docker load <$2
    docker tag citadel-backup:${backup_date} $IMAGE_NAME
    echo "Cleaning up..."
    docker rmi citadel-backup:${backup_date} &>/dev/null
    read -p "Backup restored successfully. Do you want to boot it now? (y/N) " should_boot
    echo
    if [[ $should_boot =~ [Yy]$ ]]; then
      $CLI_NAME boot
      exit
    else
      echo "All done."
      exit
    fi
    exit
  }

  read -p "Found existing Citadel installation. Do you want to overwrite it? (y/N) " should_overwrite
  echo
  if [[ $should_overwrite =~ [Yy]$ ]]; then
    echo "Destroying current Citadel..."
    docker rm $CONTAINER_NAME &>/dev/null || {
      echo 'Citadel is still running. Stop it and try again.'
      exit
    }
    docker rmi citadel &>/dev/null
    echo "Citadel image destroyed."
    $CLI_NAME restore $2
  else
    echo "Cancelled"
  fi
  exit
fi

# Rebuild a container service
if [[ "$command" = "app" ]]; then
  check_dependencies
  check_container

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  else
    args="${@:2}"
  fi

  run_in_container "scripts/app ${args}"
  exit
fi

# Stream Citadel logs
if [[ "$command" = "logs" ]]; then
  check_dependencies
  check_container

  shift
  args="$@"

  while true; do
    run_in_container "docker compose logs -f $args" || {
      echo "$(date +"%T") Trying again in 1 second..."
    }
    sleep 1
  done
  exit
fi

# Run a command inside the container
if [[ "$command" = "run" ]]; then
  check_dependencies
  check_container

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  fi

  run_in_container "$2"
  exit
fi

# Run bitcoin-cli with arguments
if [[ "$command" = "bitcoin-cli" ]]; then
  check_dependencies
  check_container

  if [ -z ${2+x} ]; then
    args=""
  else
    args="${@:2}"
  fi
  run_in_container "docker exec -t bitcoin bitcoin-cli ${args}"
  exit
fi

# Run lncli with arguments
if [[ "$command" = "lncli" ]]; then
  check_dependencies
  check_container

  if [ -z ${2+x} ]; then
    args=""
  else
    args="${@:2}"
  fi
  run_in_container "docker exec -t lightning lncli ${args}"
  exit
fi

# Fund the wallet
if [[ "$command" = "fund" ]]; then
  check_dependencies
  check_container
  check_node_network

  # default to 1 BTC
  amount=${2:-1}
  wallet_name="mywallet"

  # Check if LND wallet exists
  lnd_wallet_state=$($CLI_NAME lncli --network regtest state | jq -r '.state')

  if [[ $lnd_wallet_state == "NON_EXISTING" ]]; then
    echo "No LND Wallet found. Create a user first."
    exit 1
  fi

  # Check Bitcoin Core wallet exists
  $CLI_NAME bitcoin-cli unloadwallet $wallet_name &>/dev/null || true
  $CLI_NAME bitcoin-cli loadwallet $wallet_name &>/dev/null || {
    # Create a wallet if it doesn't exist
    $CLI_NAME bitcoin-cli createwallet $wallet_name
  }

  # Generate some blocks to get funds
  $CLI_NAME bitcoin-cli -generate 101

  # Generate a new address with LND
  address=$($CLI_NAME lncli --network regtest newaddress p2wkh | jq -r '.address')

  # Send some funds to the new address
  $CLI_NAME bitcoin-cli -named sendtoaddress address=$address amount=$amount fee_rate=1 replaceable=true

  # Mine some blocks to confirm the transaction
  $CLI_NAME bitcoin-cli -generate 6

  printf "\nAddress $address successfully funded with $amount BTC.\n"
  exit
fi

# Generate a block continuously
if [[ "$command" = "auto-mine" ]]; then
  check_dependencies
  check_container
  check_node_network

  # default to 5 seconds
  interval=${2:-5}
  wallet_name="mywallet"

  # Check Bitcoin Core wallet exists
  $CLI_NAME bitcoin-cli unloadwallet $wallet_name &>/dev/null || true
  $CLI_NAME bitcoin-cli loadwallet $wallet_name &>/dev/null || {
    # Create a wallet if it doesn't exist
    $CLI_NAME bitcoin-cli createwallet $wallet_name &>/dev/null
    echo "Created new Bitcoin Core wallet $wallet_name"
  }

  printf "Generating a block every $interval seconds. Press [CTRL+C] to stop...\n\n"

  while true; do
    $CLI_NAME bitcoin-cli -generate 1
    sleep $interval
  done

  exit
fi

# If we get here it means no valid command was supplied
# Show help and exit
show_help
exit
