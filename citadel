#!/usr/bin/env bash
set -euo pipefail

source $(dirname $0)/../scripts/functions.sh
source $(dirname $0)/../scripts/spinner.sh
source $(dirname $0)/../scripts/utils.sh

# Default to no logging (stdout and stderr to null)
VERBOSE=&>/dev/null

# Switch stdout and stderr back to normal if verbose option is sent in
while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do
if [ "$1" == "-v" ] || [ "$1" == "-verbose" ]; then
  VERBOSE=""
fi
shift; done

CLI_NAME="$(basename $0)"
CLI_VERSION="1.3.0"
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" ${VERBOSE} && pwd)
IMAGE_NAME=citadel


if [ -z ${1+x} ]; then
  command=""
else
  command="$1"
fi

# Install dependencies
if [[ "$command" = "install" ]]; then
  # install Docker
  echo 'Installing Docker...'
  if command -v "docker" 2>&1; then
    echo 'Docker is already installed. Skipping...'
  else
    sudo $SCRIPT_DIR/../scripts/install-docker.sh
  fi

  # build Citadel Docker image
  # TODO: host the image remotely
  echo 'Building Docker image...'
  docker build -t $IMAGE_NAME $SCRIPT_DIR/..

  # install Sysbox
  echo 'Installing Sysbox...'
  if command -v "sysbox" >/dev/null 2>&1; then
    echo 'Sysbox is already installed. Skipping...'
  else
    sudo $SCRIPT_DIR/../scripts/install-sysbox.sh
  fi

  echo 'Citadel dependencies installed successfully.'
  exit
fi

# Initialize a development environment
if [[ "$command" = "dev" ]]; then
  shift

  if [ -z ${1+x} ]; then
    printf "Missing target directory.\n"
    echo "Usage: \`$CLI_NAME dev <directory>\`"
    exit 1
  fi

  directory=$1
  ssh=false

  # parse arguments
  for arg in "$@"; do
    case "$1" in
    --ssh)
      ssh=true
      shift 1
      ;;
    *)
      shift 1
      ;;
    esac
  done

  # create target directory
  mkdir -p $directory

  if [[ "$(ls -A $directory)" ]]; then
    echo "Target directory must be empty!"
    exit 1
  fi

  printf "\nCloning container repositories..."

  repos="
    runcitadel/core
    runcitadel/manager
    runcitadel/middleware
    runcitadel/dashboard
    runcitadel/ui
    runcitadel/sdk
    runcitadel/fs
    runcitadel/utils
    runcitadel/node-lndconnect
    runcitadel/bitcoin-rpc"

  for repo in $repos; do
    echo

    array=(${repo//// })
    user=${array[0]}
    repo=${array[1]}

    if $ssh; then
      url="git@github.com:$user/$repo.git"
    else
      url="https://github.com/$user/$repo.git"
    fi

    git clone "$url" "$directory/$repo"

    if [[ $repo == "core" ]]; then
      printf "\nCopying Docker Compose overrides..."
      cp "$(get_script_location)/docker-compose.override.yml" "$directory/$repo"
    fi
  done

  touch "$directory/.citadel-dev"

  printf "\nYour development environment is now setup.\n"
  printf "You can boot your system container with:\n\n"
  printf "cd $directory && $CLI_NAME boot\n"
  exit
fi

# Boot the container
if [[ "$command" = "boot" ]]; then
  check_dependencies

  shift

  development=$(is_dev_environment)

  # default values
  $development && name="citadel-dev" || name="citadel"
  $development && network="regtest" || network="mainnet"
  $development && verbose=true || verbose=false

  # parse arguments
  for arg in "$@"; do
    case "$arg" in
    -n | --name)
      name=$2
      shift 1
      ;;
    -n | --network)
      case $2 in
      "mainnet" | "testnet" | "signet" | "regtest")
        network=$2
        shift 1
        ;;
      *)
        echo "Not a valid value for network"
        exit 1
        ;;
      esac
      ;;
    -v | --verbose)
      verbose=true
      shift 1
      ;;
    *)
      shift 1
      ;;
    esac
  done

  if $development; then
    echo "Found Citadel Development environment. Booting in development mode..."
    # save name to environment file
    echo $name >$PWD/.citadel-dev

    docker run --detach --publish-all \
      --runtime sysbox-runc \
      --env NETWORK=$network \
      --name $name \
      --hostname $name \
      --mount type=bind,source="$(pwd)/core",target=/home/citadel/citadel \
      --mount type=bind,source="$(pwd)/manager",target=/home/citadel/manager \
      --mount type=bind,source="$(pwd)/middleware",target=/home/citadel/middleware \
      --mount type=bind,source="$(pwd)/dashboard",target=/home/citadel/dashboard \
      --mount type=bind,source="$(pwd)/ui",target=/home/citadel/ui \
      --mount type=bind,source="$(pwd)/sdk",target=/home/citadel/sdk \
      --mount type=bind,source="$(pwd)/fs",target=/home/citadel/fs \
      --mount type=bind,source="$(pwd)/utils",target=/home/citadel/utils \
      --mount type=bind,source="$(pwd)/node-lndconnect",target=/home/citadel/node-lndconnect \
      --mount type=bind,source="$(pwd)/bitcoin-rpc",target=/home/citadel/bitcoin-rpc \
      $IMAGE_NAME \
      $VERBOSE || {
      echo "Container with name \"$name\" exists already. Either remove (or rename) it or create a new one by passing a different name with \`$CLI_NAME boot --name <name>\`."
      exit 1
    }
  else
    echo "Booting..."
    docker run --runtime sysbox-runc- -env NETWORK=$network --detach --publish-all --name $name --hostname $name $IMAGE_NAME $VERBOSE || {
      echo "Container with name \"$name\" exists already. Either remove (or rename) it or create a new one by passing a different name with \`$CLI_NAME boot --name <name>\`."
      exit 1
    }
  fi

  if $verbose; then
    echo 'Citadel is starting up. Listening for logs...'
    # wait for container
    # TODO: this is very unreliable
    sleep 5
    # Log until Citadel is up
    run_in_container "journalctl -f -u citadel-startup | sed '/Citadel is now accessible at/ q'"
  else
    start_spinner "Citadel is spinning up containers... This will only take a minute."
    wait_for_dashboard
    stop_spinner $?
  fi

  show_welcome $network $name $(get_container_ip) $development
  read -p "Do you want to log in now? (y/N) " should_login
  echo
  if [[ $should_login =~ [Yy]$ ]]; then
    $CLI_NAME ssh
  fi

  exit
fi

# List all Citadel containers with their status in a table format
if [[ "$command" = "list" ]] || [[ "$command" = "ls" ]]; then
  check_dependencies

  TEMPFILE=$(mktemp)
  trap "rm -f $TEMPFILE" EXIT

  echo "NAME|CONTAINER ID|HOSTNAME|IP|STATUS" >>$TEMPFILE

  containers=$(docker ps --all --filter "ancestor=citadel" --format '{{.Names}}')
  for container in $containers; do
    info=$(docker inspect -f '{{.Id}}|{{.Config.Hostname}}|{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}|{{.State.Status}}' $container)
    echo "$container|$info" >>$TEMPFILE
  done

  column -t -s'|' $TEMPFILE

  exit
fi

# Get an SSH session inside the container
if [[ "$command" = "ssh" ]]; then
  check_dependencies
  check_container_name
  target_container=$(get_container_name)
  check_container_running $target_container

  # TODO: add target argument

  # get host IPs
  addresses=($(ip addr | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'))

  # get container port
  port=$(docker container inspect --format='{{(index (index .NetworkSettings.Ports "22/tcp") 0).HostPort}}' $target_container)

  if [ -z ${2+x} ]; then
    ssh -t citadel@${addresses[0]} -p $port 'cd /home/citadel/citadel && exec bash -l'
  else
    shift

    # parse arguments
    for arg in "$@"; do
      case "$arg" in
      list)
        printf "Use one of the following commands to ssh in from another device:\n\n"
        for address in ${addresses[@]}; do
          echo "ssh citadel@${address} -p $port"
        done
        exit 1
        ;;
      help | *)
        cat <<EOF
Usage: ${CLI_NAME} ssh <command>

Commands:
    help              Show this help message
    list              List IP adresses
EOF
        exit 1
        ;;
      esac
    done
  fi

  exit
fi

# Start the container
if [[ "$command" = "start" ]]; then
  check_dependencies

  # get target container
  if [ -z ${2+x} ]; then
    check_container_name
    target_container=$(get_container_name)
  else
    target_container=$2
  fi
  check_container_exists $target_container

  if [ "$(docker container inspect -f '{{.State.Running}}' $target_container)" == "true" ]; then
    echo "Citadel is already running"
    exit 1
  else
    printf "Starting Citadel...\n\n"
<<<<<<< HEAD
    docker start $target_container $VERBOSE
=======
    # ignore stdout, but show stderr
    docker start $target_container 2>&1 >/dev/null
>>>>>>> main
    printf "Citadel started.\n\n"
    read -p "Do you want to log in now? (y/N) " should_login
    echo
    if [[ $should_login =~ [Yy]$ ]]; then
      $CLI_NAME ssh
    fi
  fi
  exit
fi

# Stop the container
if [[ "$command" = "stop" ]]; then
  check_dependencies

  # get target container
  if [ -z ${2+x} ]; then
    check_container_name
    target_container=$(get_container_name)
  else
    target_container=$2
  fi
  check_container_exists $target_container

  echo "Shutting down Citadel..."
<<<<<<< HEAD
  docker stop $target_container $VERBOSE
=======
  docker stop $target_container 2>&1 >/dev/null
>>>>>>> main
  exit
fi

# Reload the Citadel service
if [[ "$command" = "reload" ]]; then
  check_dependencies

  # get target container
  if [ -z ${2+x} ]; then
    check_container_name
    target_container=$(get_container_name)
  else
    target_container=$2
  fi
  check_container_exists $target_container

  printf "Reloading the Citadel service...\n\n"
  run_in_container "scripts/stop && scripts/configure && scripts/start"
  exit
fi

# Destroy the container
if [[ "$command" = "destroy" ]]; then
  check_dependencies

  # get target container
  if [ -z ${2+x} ]; then
    check_container_name
    target_container=$(get_container_name)
  else
    target_container=$2
  fi
  check_container_exists $target_container

  echo "WARNING: This will completely remove the container and its data."
  echo "If you just want to stop the container run \`$CLI_NAME stop\`"
  read -p "Are you sure? (y/N) "
  echo
  if [[ $REPLY =~ [Yy]$ ]]; then
    echo "Destroying container..."
    docker rm -f $target_container $VERBOSE
    echo "Citadel container destroyed"
  else
    echo "Cancelled."
  fi
  exit
fi

# List container services
if [[ "$command" = "containers" ]]; then
  check_dependencies
  check_container_name

  run_in_container "docker compose config --services"
  exit
fi

# Rebuild a container service
if [[ "$command" = "rebuild" ]]; then
  check_dependencies
  check_container_name

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  fi

  container="$2"
  run_in_container "                    \
       docker compose build $container  \
    && docker compose stop $container   \
    && docker compose rm -f $container  \
    && DEVICE_HOSTS=$(get_container_hostname) docker compose up -d $container"
  exit
fi

# Backup the container
if [[ "$command" = "backup" ]]; then
  check_dependencies
  check_container_name

  current_date=$(date '+%Y-%m-%d')

  echo "Stopping Citadel services..."
  run_in_container "scripts/stop" $VERBOSE
  echo "Creating snapshot..."
  docker commit $(get_container_name) citadel-backup:${current_date}
  echo "Backing up..."
  docker save citadel-backup:${current_date} | gzip >citadel-backup-${current_date}.tar.gz
  echo "Cleaning up..."
  docker rmi citadel-backup:${current_date} $VERBOSE
  echo "Done! Backup saved to ./citadel-backup-${current_date}.tar.gz"
  exit
fi

# Restore a backup
if [[ "$command" = "restore" ]]; then
  check_dependencies

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  fi

  # TODO: we aren't really using the date here atm
  backup_date=${2:15:10}

  # check for current container
  docker container inspect $(get_container_name) $VERBOSE || {
    # load & rename
    echo "Restoring from backup $2..."
    docker load <$2
    docker tag citadel-backup:${backup_date} $IMAGE_NAME
    echo "Cleaning up..."
    docker rmi citadel-backup:${backup_date} $VERBOSE
    read -p "Backup restored successfully. Do you want to boot it now? (y/N) " should_boot
    echo
    if [[ $should_boot =~ [Yy]$ ]]; then
      $CLI_NAME boot
      exit
    else
      echo "All done."
      exit
    fi
    exit
  }

  read -p "Found existing Citadel installation. Do you want to overwrite it? (y/N) " should_overwrite
  echo
  if [[ $should_overwrite =~ [Yy]$ ]]; then
    echo "Destroying current Citadel..."
    docker rm $(get_container_name) $VERBOSE || {
      echo 'Citadel is still running. Stop it and try again.'
      exit
    }
    docker rmi $IMAGE_NAME $VERBOSE
    echo "Citadel image destroyed."
    $CLI_NAME restore $2
  else
    echo "Cancelled"
  fi
  exit
fi

# Rebuild a container service
if [[ "$command" = "app" ]]; then
  check_dependencies
  check_container_name

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  else
    args="${@:2}"
  fi

  run_in_container "scripts/app ${args}"
  exit
fi

# Stream Citadel logs
if [[ "$command" = "logs" ]]; then
  check_dependencies
  check_container_name

  shift
  args="$@"

  while true; do
    run_in_container "docker compose logs -f $args" || {
      echo "$(date +"%T") Trying again in 1 second..."
    }
    sleep 1
  done
  exit
fi

# Run a command inside the container
if [[ "$command" = "run" ]]; then
  check_dependencies
  check_container_name

  if [ -z ${2+x} ]; then
    echo "A second argument is required!"
    exit 1
  fi

  run_in_container "$2"
  exit
fi

# Run bitcoin-cli with arguments
if [[ "$command" = "bitcoin-cli" ]]; then
  check_dependencies
  check_container_name
  check_inner_container "bitcoin"

  if [ -z ${2+x} ]; then
    args=""
  else
    args="${@:2}"
  fi
  run_in_container "docker exec -t bitcoin bitcoin-cli ${args}"
  exit
fi

# Run lncli with arguments
if [[ "$command" = "lncli" ]]; then
  check_dependencies
  check_container_name
  check_inner_container "lightning"

  if [ -z ${2+x} ]; then
    args=""
  else
    args="${@:2}"
  fi
  run_in_container "docker exec -t lightning lncli ${args}"
  exit
fi

# Fund the wallet
if [[ "$command" = "fund" ]]; then
  check_dependencies
  check_dev_environment
  check_node_network
  check_inner_container "lightning"
  check_inner_container "bitcoin"

  # default to 1 BTC
  amount=${2:-1}
  wallet_name="mywallet"

  # Check if LND wallet exists
  lnd_wallet_state=$($CLI_NAME lncli --network regtest state | jq -r '.state')

  if [[ $lnd_wallet_state == "NON_EXISTING" ]]; then
    echo "No LND Wallet found. Create a user first."
    exit 1
  fi

  # Check Bitcoin Core wallet exists
  $CLI_NAME bitcoin-cli unloadwallet $wallet_name $VERBOSE || true
  $CLI_NAME bitcoin-cli loadwallet $wallet_name $VERBOSE || {
    # Create a wallet if it doesn't exist
    $CLI_NAME bitcoin-cli createwallet $wallet_name
  }

  # Generate some blocks to get funds
  $CLI_NAME bitcoin-cli -generate 101

  # Generate a new address with LND
  address=$($CLI_NAME lncli --network regtest newaddress p2wkh | jq -r '.address')

  # Send some funds to the new address
  $CLI_NAME bitcoin-cli -named sendtoaddress address=$address amount=$amount fee_rate=1 replaceable=true

  # Mine some blocks to confirm the transaction
  $CLI_NAME bitcoin-cli -generate 6

  printf "\nAddress $address successfully funded with $amount BTC.\n"
  exit
fi

# Generate a block continuously
if [[ "$command" = "auto-mine" ]]; then
  check_dependencies
  check_dev_environment
  check_node_network
  check_inner_container "bitcoin"

  # default to 5 seconds
  interval=${2:-5}
  wallet_name="mywallet"

  # Check Bitcoin Core wallet exists
  $CLI_NAME bitcoin-cli unloadwallet $wallet_name $VERBOSE || true
  $CLI_NAME bitcoin-cli loadwallet $wallet_name $VERBOSE || {
    # Create a wallet if it doesn't exist
    $CLI_NAME bitcoin-cli createwallet $wallet_name $VERBOSE
    echo "Created new Bitcoin Core wallet $wallet_name"
  }

  printf "Generating a block every $interval seconds. Press [CTRL+C] to stop...\n\n"

  while true; do
    $CLI_NAME bitcoin-cli -generate 1
    sleep $interval
  done

  exit
fi

# Show version information for this CLI
if [[ "$command" = "version" ]]; then
  echo "$CLI_NAME v$CLI_VERSION"
  exit
fi

# If we get here it means no valid command was supplied
# Show help and exit
show_help
exit
